{"version":3,"sources":["../../src/connectStyle.js"],"names":["_","throwConnectStyleError","errorMessage","componentDisplayName","Error","getTheme","context","theme","getDefaultTheme","componentStyleName","componentStyle","mapPropsToStyleNames","options","getComponentDisplayName","WrappedComponent","displayName","name","wrapWithStyledComponent","isPlainObject","isString","StyledComponent","props","styleNames","resolveStyleNames","resolvedStyle","resolveStyle","setWrappedInstance","bind","resolveConnectedComponentStyle","state","style","childrenStyle","addedProps","resolveAddedProps","parentStyle","virtual","nextProps","nextContext","shouldRebuildStyle","setState","nativeProps","wrappedInstance","setNativeProps","component","_root","isEqual","styleName","hasStyleNameChanged","split","uniq","withRef","ref","themeStyle","createComponentStyle","Component","contextTypes","object","childContextTypes","func","propTypes","string","bool","defaultProps"],"mappings":"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","file":"connectStyle.js","sourcesContent":["import React, { PropTypes } from 'react';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\nimport normalizeStyle from './StyleNormalizer/normalizeStyle';\n\nimport Theme, { ThemeShape } from './Theme';\nimport { resolveComponentStyle } from './resolveComponentStyle';\n\n/**\n * Formats and throws an error when connecting component style with the theme.\n *\n * @param errorMessage The error message.\n * @param componentDisplayName The name of the component that is being connected.\n */\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\n  throw Error(`${errorMessage} - when connecting ${componentDisplayName} component to style.`);\n}\n\n/**\n * Returns the theme object from the provided context,\n * or an empty theme if the context doesn't contain a theme.\n *\n * @param context The React component context.\n * @returns {Theme} The Theme object.\n */\nfunction getTheme(context) {\n  // Fallback to a default theme if the component isn't\n  // rendered in a StyleProvider.\n  return context.theme || Theme.getDefaultTheme();\n}\n\n/**\n * Resolves the final component style by using the theme style, if available and\n * merging it with the style provided directly through the style prop, and style\n * variants applied through the styleName prop.\n *\n * @param componentStyleName The component name that will be used\n * to target this component in style rules.\n * @param componentStyle The default component style.\n * @param mapPropsToStyleNames Pure function to customize styleNames depending on props.\n * @param options The additional connectStyle options\n * @param options.virtual The default value of the virtual prop\n * @param options.withRef Create component ref with addedProps; if true, ref name is wrappedInstance\n * @returns {StyledComponent} The new component that will handle\n * the styling of the wrapped component.\n */\nexport default (componentStyleName, componentStyle = {}, mapPropsToStyleNames, options = {}) => {\n  function getComponentDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  }\n\n  return function wrapWithStyledComponent(WrappedComponent) {\n    const componentDisplayName = getComponentDisplayName(WrappedComponent);\n\n    if (!_.isPlainObject(componentStyle)) {\n      throwConnectStyleError(\n        'Component style must be plain object',\n        componentDisplayName\n      );\n    }\n\n    if (!_.isString(componentStyleName)) {\n      throwConnectStyleError(\n        'Component Style Name must be string',\n        componentDisplayName\n      );\n    }\n\n    class StyledComponent extends React.Component {\n      static contextTypes = {\n        theme: ThemeShape,\n        // The style inherited from the parent\n        parentStyle: PropTypes.object,\n      };\n\n      static childContextTypes = {\n        // Provide the parent style to child components\n        parentStyle: PropTypes.object,\n        resolveStyle: PropTypes.func,\n      };\n\n      static propTypes = {\n        // Element style that overrides any other style of the component\n        style: PropTypes.object,\n        // The style variant names to apply to this component,\n        // multiple variants may be separated with a space character\n        styleName: PropTypes.string,\n        // Virtual elements will propagate the parent\n        // style to their children, i.e., the children\n        // will behave as they are placed directly below\n        // the parent of a virtual element.\n        virtual: PropTypes.bool,\n      };\n\n      static defaultProps = {\n        virtual: options.virtual,\n      };\n\n      static displayName = `Styled(${componentDisplayName})`;\n      static WrappedComponent = WrappedComponent;\n\n      constructor(props, context) {\n        super(props, context);\n        const styleNames = this.resolveStyleNames(props);\n        const resolvedStyle = this.resolveStyle(context, props, styleNames);\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\n        this.resolveConnectedComponentStyle = this.resolveConnectedComponentStyle.bind(this);\n        this.state = {\n          style: resolvedStyle.componentStyle,\n          childrenStyle: resolvedStyle.childrenStyle,\n          // AddedProps are additional WrappedComponent props\n          // Usually they are set trough alternative ways,\n          // such as theme style, or trough options\n          addedProps: this.resolveAddedProps(),\n          styleNames,\n        };\n      }\n\n      getChildContext() {\n        return {\n          parentStyle: this.props.virtual ?\n            this.context.parentStyle :\n            this.state.childrenStyle,\n          resolveStyle: this.resolveConnectedComponentStyle,\n        };\n      }\n\n      componentWillReceiveProps(nextProps, nextContext) {\n        const styleNames = this.resolveStyleNames(nextProps);\n        if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\n          const resolvedStyle = this.resolveStyle(nextContext, nextProps, styleNames);\n          this.setState({\n            style: resolvedStyle.componentStyle,\n            childrenStyle: resolvedStyle.childrenStyle,\n            styleNames,\n          });\n        }\n      }\n\n      setNativeProps(nativeProps) {\n        if (this.wrappedInstance.setNativeProps) {\n          this.wrappedInstance.setNativeProps(nativeProps);\n        }\n      }\n\n      setWrappedInstance(component) {\n        if(component && component._root) {\n          this._root = component._root;\n        } else {\n          this._root = component;\n        }\n      }\n\n      hasStyleNameChanged(nextProps, styleNames) {\n        return mapPropsToStyleNames && this.props !== nextProps &&\n          // Even though props did change here,\n          // it doesn't necessary means changed props are those which affect styleName\n          !_.isEqual(this.state.styleNames, styleNames);\n      }\n\n      shouldRebuildStyle(nextProps, nextContext, styleNames) {\n        return (nextProps.style !== this.props.style) ||\n          (nextProps.styleName !== this.props.styleName) ||\n          (nextContext.theme !== this.context.theme) ||\n          (nextContext.parentStyle !== this.context.parentStyle) ||\n          (this.hasStyleNameChanged(nextProps, styleNames));\n      }\n\n      resolveStyleNames(props) {\n        const { styleName } = props;\n        const styleNames = styleName ? styleName.split(/\\s/g) : [];\n\n        if (!mapPropsToStyleNames) {\n          return styleNames;\n        }\n\n        // We only want to keep the unique style names\n        return _.uniq(mapPropsToStyleNames(styleNames, props));\n      }\n\n      resolveAddedProps() {\n        const addedProps = {};\n        if (options.withRef) {\n          addedProps.ref = 'wrappedInstance';\n        }\n        return addedProps;\n      }\n\n      resolveStyle(context, props, styleNames) {\n        const { parentStyle } = context;\n        const style = normalizeStyle(props.style);\n\n        const theme = getTheme(context);\n        const themeStyle = theme.createComponentStyle(componentStyleName, componentStyle);\n\n        return resolveComponentStyle(\n          componentStyleName,\n          styleNames,\n          themeStyle,\n          parentStyle,\n          style\n        );\n      }\n\n      /**\n       * A helper function provided to child components that enables\n       * them to resolve their style for any set of prop values.\n       *\n       * @param props The component props to use to resolve the style values.\n       * @returns {*} The resolved component style.\n       */\n      resolveConnectedComponentStyle(props) {\n        const styleNames = this.resolveStyleNames(props);\n        return this.resolveStyle(this.context, props, styleNames).componentStyle;\n      }\n\n      render() {\n        const { addedProps, style } = this.state;\n        return (\n          <WrappedComponent\n            {...this.props}\n            {...addedProps}\n            style={style}\n            ref={this.setWrappedInstance}\n          />);\n      }\n    }\n\n    return hoistStatics(StyledComponent, WrappedComponent);\n  };\n};\n"]}